
<!--********************************************************************-->

<section xml:id="sec-builtin-functions" xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Built-In Functions</title>

	<objectives>
		<introduction>
			<p>
				By the end of this section, you will be able to ...
			</p>
		</introduction>
		<ol>
			<li></li>
		</ol>
	</objectives>

	<introduction>
		<p>
			
		</p>
	</introduction>

	<p>
		In this section, we look at some functions that are built-in to Matlab.  In a later section, we discuss how a user may write their own.
	</p>

	<p>
		As with most parts of Matlab, the Help window is useful in describing the functions that are in Matlab, Simulink, and any toolbox add-ons that you may have.  To access the entire list of functions, grouped in various ways, click on the Help button, the one shaped like a question mark at the top of the main Matlab window, or simply use the <kbd>F1</kbd> button.  
	</p>

	<p>
		In discovering what a function does, we suggest to simply try it. Let's look at a few of MATLAB's commonly used built-in functions.
	</p>

	<example xml:id="builtin-sqrt">
	<title><em><m>\texttt{sqrt(A)}\,\,\,</m></em></title><p/>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; A = [1 2 49 4; 25 36 3 81]
					A =
					    1     2    49     4
					   25    36     3    81

					&gt;&gt; sqrt(A)
					ans =
					    1.0000    1.4142    7.0000    2.0000
					    5.0000    6.0000    1.7321    9.0000
				</code>
			</program>
		</sidebyside>

		<p>
			This is (hopefully) what you might expect.  It finds the square root of each of the entries.
			<fn>
				<p>
					If you know a little more linear algebra and was expecting the "principal" square root, or a matrix <c>B</c> so that <c>B * B = A</c>, this is created using <c>B = sqrtm(A)</c>.
				</p>
			</fn>
		</p>
	</example>

	<example xml:id="builtin-sin">
	<title><m>\texttt{sin(A), sind(A)}\quad\,\,</m></title><p/>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; A = [90 pi/2 ; 180 pi]
					A = 
					    90.0000    1.5708
					   180.0000    3.1416

					&gt;&gt; sin(A)
					ans =
					    0.8940    1.0000
					   -0.8012    0.0000

					&gt;&gt; sind(A)
					ans =
					    1.0000    0.0274
					         0    0.0548
				</code>
			</program>
		</sidebyside>

		<p>
			Both of these functions compute the sine of each value in <c>A</c>, however,
			<ul>
				<li> 
					<p>
						<c>sin(A)</c> assumes the values in <c>A</c> are in radians, while
					</p>
				</li>
				<li>
					<p>
						<c>sind(A)</c> assumes the values in <c>A</c> are in degrees.
					</p>
				</li>
			</ul>
		</p>

		<p>
			The other trigonometric functions are similarly named.
		</p>

	</example>

	<example xml:id="builtin-exp-log">
	<title><m>\texttt{exp(A), log(A), log10(A)}\qquad\,</m></title><p/>

		<p>
			These three functions are base <m>e</m> exponentiation, the natural log and the logarithm base 10.  They act entry-wise:
		</p>
		
		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; A = [1 2 49 4; 25 36 3 81];

					&gt;&gt; exp(A)
					ans =
					1.0e+035 *
					    0.0000    0.0000    0.0000    0.0000
					    0.0000    0.0000    0.0000    1.5061

					&gt;&gt; log(A)
					ans =
					         0    0.6931    3.8918    1.3863
					    3.2189    3.5835    1.0986    4.3944

					&gt;&gt; log10(A)
					ans =
					         0    0.3010    1.6902    0.6021
					    1.3979    1.5563    0.4771    1.9085
					</code>
			</program>
			</sidebyside>

		<p>
			We do see something curious here for the function <c>exp(A)</c>.  It looks like all of the entries are zero until a closer look shows the 
			leading term "<c>1.0e+035 *</c>".  This means that every entry in the answer is multiplied by this factor <m>10^{35}</m> (a rather large number).  The fact that the other entries look like zero is that there aren't enough decimal places to store each answer.
		</p>
	</example>
	
	<example xml:id="builtin-mean-median-std">
	<title><m>\texttt{mean(A), median(A), std(A)}\qquad\,\,</m></title><p/>

		<p>
			These are some of the basic statistical functions.  The output for these are the mean, meadian, and standard deviation of the columns of <c>A</c>.
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; A = [1 2 49 4; 25 36 3 81];

					&gt;&gt; mean(A)
					ans =
					    13.0000   19.0000   26.0000   42.5000

					&gt;&gt; std(A)
					ans =
					    16.9706   24.0416   32.5269   54.4472

					&gt;&gt; median(A)
					ans =
					    13.0000   19.0000   26.0000   42.5000
				</code>
			</program>
		</sidebyside>

	</example>

	<example xml:id="builtin-sort">
	<title><m>\texttt{sort(A), sortrows(A)}\qquad</m></title><p/>

		<p>
			The command <c>sort</c> rearranges the data in the columns of <c>A</c> in increasing order.  The command <c>sortrows</c> sorts the rows of <c>A</c> in increasing order (determined by the first column).
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; A = [1 2 49 4; 25 36 3 81];

					&gt;&gt; sort(A)
					ans =
					    1   2   3   4
					   25  36  49  81

					&gt;&gt; sortrows(A)
					ans =
					    1   2  49    4
					   25  36   3   81
				</code>
			</program>
		</sidebyside>

		<p>
			However, both of these functions can take other arguments.  For example, the <c>sort</c> function can also be used to sort the columns, or can sort using either 'descend' or 'ascend'.  The <c>sortrows</c> function can also be used to sort according to other columns.  See the Help files for more details.
		</p>

	</example>
		    
	<example xml:id="builtin-flip">
	<title><m>\texttt{flipud(A), fliplr(A)}\qquad</m></title><p/>

		<p>
			These two functions are abbreviations of "flip up-and-down" and "flip left-to-right".  That's exactly what they do:
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; A = [1 2 49 4; 25 36 3 81];

					&gt;&gt; flipud(A)
					ans =
					   25  36    3  81
					    1   2   49   4

					&gt;&gt; fliplr(A)
					ans =
					    4  49    2   1
					   81   3   36  25
				</code>
			</program>
		</sidebyside>
	
	</example>

	<example xml:id="builtin-find">
	<title><m>\texttt{find}\,\,</m></title><p/>

		<p>
			The function <c>find</c> is used to located the position of values in a matrix.   
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; A = [1 2 49 4; 25 36 3 81];

					&gt;&gt; find(A==1)
					ans =
					    1
				</code>
			</program>
		</sidebyside>

		<p>
			A couple of comments about this example.  First, there is a double equals sign in <c>A==1</c>.  There will be more about this in a future chapter (on relational operators), but you can read this as a question "does <c>A</c> equal 1?." The entire line <c>find(A==1)</c> indicates the location where the (element of) <c>A</c> does in fact equal 1 (namely the first entry).  Another example:
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; find(a&gt;5)
					ans =
					    2
					    4
					    5
					    8
				</code>
			</program>
		</sidebyside>

		<p>
			Here we must again remember to read down the columns of <c>A</c> to get to the 2nd, 4th, 5th and 8th entries.  We can tweak this last example to get the exact rows and columns containing entries greater than 5:
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; [r,c]=find(A&gt;5); [r,c]
					ans =
					    2     1
					    2     2
					    1     3
					    2     4
				</code>
			</program>
		</sidebyside>

		<p>
			Here we have given the <c>find</c> function two outputs to write to, the variables <c>r</c> and <c>c</c>, which are displayed together for easier reading using <c>[r,c]</c>.  The output indicates that the entries of <c>A</c> that are greater than <m>5</m> can be found in the
			2nd row &amp; 1st column, 2nd row &amp; 2nd column, 1st row &amp; 3rd column, and 2nd row &amp; 4th column.
		</p>

		<p>
			In the next example, we investigate the function <c>meshgrid</c>.  The command <c>meshgrid</c> function is used to transform vectors <c>x</c> and <c>y</c> into arrays <c>X</c> and <c>Y</c> of sizes appropriate for computation and plotting.
		</p>

	</example>

	<example xml:id="builtin_meshgrid"><p/>
	<title><m>\texttt{meshgrid}\quad</m></title><p/>

		<p>
			Suppose we wanted to compute the area of a triangle for all possible combinations of the base, ranging from 7 to 10 units, and the height, ranging from 2 to 6 units.  Here's the set up (output suppressed):
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
						&gt;&gt; Base = 7:10; 
						&gt;&gt; Height = 2:6; 
				</code>
			</program>
		</sidebyside>

		<p>
			Now, we can't just multiply these two matrices together, nor can we "dot multiply" them either, since the dimensions of <c>Base</c>, <m>1 \times 4</m>, and <c>Height</c>, <m>1 \times 5</m>, do not line up properly in either case.  Instead we resize using <c>meshgrid</c>:
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; [NewBase,NewHeight] = meshgrid(Base,Height)
				</code>
			</program>
		</sidebyside>

		<p>
			This creates two matrices, <c>NewBase</c> and <c>NewHeight</c>, which are both <m>5 \times 4</m>.  We did not suppress the output, so one can see that these are:
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					NewBase =
					    7  8  9  10
					    7  8  9  10
					    7  8  9  10
					    7  8  9  10
					    7  8  9  10
				</code>
			</program>
		</sidebyside>

		<p>
			and
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					NewHeight =
					    2 2 2 2
					    3 3 3 3
					    4 4 4 4
					    5 5 5 5
					    6 6 6 6
				</code>
			</program>
		</sidebyside>

		<p>
			We can now "dot multiply" them together:
		</p>

		<sidebyside width="100%">
			<program language="matlab">
				<code>
					&gt;&gt; Area= (NewBase.*NewHeight)/2

					Area =
					    7.0000    8.0000    9.0000   10.0000
					   10.5000   12.0000   13.5000   15.0000
					   14.0000   16.0000   18.0000   20.0000
					   17.5000   20.0000   22.5000   25.0000
					   21.0000   24.0000   27.0000   30.0000
				</code>
			</program>
		</sidebyside>
	</example>

</section>


